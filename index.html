<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/moon.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/atom-one-dark.css">


  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);

  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <!-- Heading section -->
      <section data-markdown>
        <textarea data-template>
            ## Make your App Transparent
	      </textarea>
      </section>


      <section data-transition="fade-out">
        <h3>What to expect in this talk? </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          Basic Functional Desgin
          Attribute Grammer
          Recursion Schemes
        </code></pre>
      </section>



      <section data-transition="fade-out">
        <h3>Our usecase: An app to make platform transparent</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          Make your platform observable through metrics with a metrics UI
          There existed a service that runs in the backend to calculate these metrics
          Metrics existed in various shapes in different sources
          Took days or even weeks to bring this metrics in production
        </code></pre>
      </section>


      <section data-transition="fade-out">
        <h3>Metrics calculation</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          
        1. Data for a feature/metric can exist in multiple sources.
        2. At different time periods - union 
        3. Or even you need to try multiple sources
        4. + optimisations 

        </code></pre>
      </section>


      <section data-transition="fade-out">
        <h3>Metrics calculation</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          
        1. When you ask the service for a metric, can it emit a plan on what to execute?
        2. Can it then emit a summary of the details of executed computation ? 

        </code></pre>
      </section>

      <section data-transition="fade-out">
        <h3>Analytics Engine</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          
        Infact, we started with a specific problem but essentially
        the problem statement is quite common in our industry.

        </code></pre>
      </section>

      <!-- Slide 2 -->
      <section data-transition="fade-out">
        <h3>How to solve?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          
        An execution planner
        An execution summary

        </code></pre>
      </section>

      <!-- Slide 2 -->
      <section data-transition="fade-out">
        <h3>How to solve?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
         // In our case we need to be able to define a metric
         sealed trait Metric[A]

         object Metric {
          case class Source[A](dataSource: DataSource[A])                     extends Metric[A] 
          case class Ratio[A](numerator: Metric[A], denominator: Metric[A])   extends Metric[A]
          case class Sum[A](left: Metric[A], right: Metric[A])                extends Metric[A]
          case class OrElse[A](left: MetricDsl[A], right: MetricDsl[A])       extends MetricDsl[A]
          case class Within[A](metric: Metric[A], start: RelativeTime, end: RelativeTime) extends Metric[A]
         }
      
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>DataSource</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
     sealed trait RelativeTime
       
     object RelativeTime {
       final case object Now                          extends RelativeTime
       final case object Epoch                        extends RelativeTime
       final case class BeforeNow(duration: Duration) extends RelativeTime
       final case class At(instant: Instant)          extends RelativeTime
     }

        </code></pre>
      </section>


      <!-- Slide 3 -->

      <section data-transition="fade-in">
        <h3>DataSource</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          sealed trait DataSource[A] 

          object DataSource {
            final case class Empty[A]()                                  extends DataSource[A]
            final case class AwsS3[A](metricName: String)                extends DataSource[A]
            final case class Postgres[A](from: AuroraLogic[A])           extends DataSource[A]
            final case class InMemoryCache[A](dataSource: DataSource[A]) extends DataSource[A]
          }

        </code></pre>
      </section>

      <!-- Slide 4 -->

      <section data-transition="fade-in">
        <h3>Query</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          // We need to represent the operations done at each datasource level
          sealed trait Query[A]

          object Query {
            final case class FromCache[A](input: DataSource[_], window: Window) extends Query[A]
            final case class FromS3[A](request: S3.Request) extends Query[A]
            sealed trait SqlQuery[A] extends Query[A]
            object SqlQuery {
              ....

            }

          }

        </code></pre>
      </section>

      <!-- Slide 5-->
      <section data-transition="fade-in">
        <h3>Sql Query</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          final case class Select[A](expr: Expr[A]) extends SqlQuery[A]
          final case class From[A](q1: SqlQuery[A], q2: SqlQuery[A]) extends SqlQuery[A]
          final case class Filter[A](query: SqlQuery[A], expr: Expr[Boolean]) extends SqlQuery[A]
          final case class GroupBy[A, B](query: SqlQuery[A], expr: Expr[B]) extends SqlQuery[A] 
          final case class InnerJoin[A, B](q1: SqlQuery[A], q2: SqlQuery[B], onLeft: String, onRight: String) extends SqlQuery[A]
        </code></pre>
      </section>

      <!-- Slide 5-->
      <section data-transition="fade-in">
        <h3>Execution Plan</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
           An abstraction that is closer to the implementation
           That's called Ops
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Execution Plan</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
  sealed trait Ops[A]

  object Ops {
    final case class Noop[A](query: A) extends Ops[A]
    final case class Partial[A](ops: Ops[A], forWindow: Window, remainingWindow: Window) extends Ops[A]
    final case class Union[A](left: Ops[A], leftWindow: Window, right: Ops[A], rightWindow: Window) extends Ops[A]
    final case class Fail[A](message: String) extends Ops[A]
    final case class Sum[A](nonEmptyChunk: NonEmptyChunk[Ops[C, A]], executionStrategy: Option[ExecutionStrategy] = None) extends Ops[A]
    final case class OrElse[A](self: Ops[C, A], leftWindow: Window, that: Ops[C, A], rightWindow: Window) extends Ops[A]
  }

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Program Flow</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          Request                 => Ops[Query[(String, A)]]
          Ops[Query[(String, A)]] => Ops[ZStream[Any, Error, (String, A)]]
          Ops[ZStream[Any, Error, (String, A)]] => ZStream[Any, Error, (String, A)]
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Execution Flow</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-20">
          def plan(request: Request[A]): Ops[Query[(String, A)]] = {
            request.metric match {
              case Metric.Within(metric, start, end) => 
                val requested = request.window
                val available = Window(start.toInstant(now), end.toInstant(now))

              if (requested.isSubsetOf(available)) {
                plan(request.withMetric(metric)).map(_.withWindow(requested))
              } else if (requested.isNotIn(available)) {
                Ops.Fail("The metric is not available in the data-source")
              } else {
                Ops.Partial(plan(request.withMetric(metric).withWindow(requested.intersect(available))))
              }    
            }
          }
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Execution Flow</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-20">
          
          case MetricDsl.OrElse(m1, m2) =>
            (plan(request.withMetric(m1)), plan(request.withMetric(m2))) match {
              // Skipped a few others
              case (Ops.Partial(query1, w1, _), Ops.Partial(query2, w2, _)) => Ops.Union(query1, w1, query2, w2)
              case (ops1, ops2)                                             => Ops.OrElse(ops1, request.window, ops2, request.window)
            }
        </code></pre>
      </section>


      <!-- Slide -->
      <section data-transition="fade-out">
        <h3>Metric was Data, and ExecPlan is Data too</h3>

        Well that's your plan, which is Ops[Query[A]]

      </section>

      <section data-transition="fade-in">
        <h3>Pretty Printing it is easy</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-20">
          case MetricDsl.OrElse(m1, m2) =>
            (plan(request.withMetric(m1)), plan(request.withMetric(m2))) match {
              // Skipped a few others
              case (Ops.Partial(query1, w1, _), Ops.Partial(query2, w2, _)) => Ops.Union(query1, w1, query2, w2)
              case (ops1, ops2)                                             => Ops.OrElse(ops1, request.window, ops2, request.window)
            }
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Pretty Printing it is easy</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-20">
        def toJson(f: B => Json): Json =
          plan match {
            case Ops.Noop(query) =>
              f(query)
    
            case Ops.Partial(ops, _, _) =>
              Json.Obj(Chunk(("partial", ops.toJson(f))))
    
            case Ops.Fail(err) =>
              Json.Obj(Chunk(("fail", Json.Str(err))))
    
            case Ops.Sum(chunk, _) =>
              Json.Obj(Chunk(("sum", Json.Arr(chunk.map(_.toJson(f))))))
    
            ....
    
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Execution Plan: Ops[Query[A]]</h3>
        <pre><code class="hljs json" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
      "union": [
        {"fall-back": [
          "request-cache-metric-name-for-time-2021-09-16T08:27:28Z-and-2021-09-1608:31:00Z",
          "request-database-SELECT value, COUNT(DISTINCT(abc.def)) FROM my_Table where time > '2021-09-16T08:27:28Z' AND time < '2021-09-16T08:29:00Z "
          ]
        },
        {"fall-back": [
          "request-cache-AWSS3(my_metric_name)",
            { "sum": [
                "request-aws-s3:Request(2021,9,16,8,Some(30),List(my_metric_name),location)",
                "request-aws-s3:Request(2021,9,16,8,Some(31),List(my_metric_name),location)"
              ]
            }
          ]
        }
      ]
        </code></pre>
      </section>

      <!-- Slide -->
      <section data-transition="fade-in">
        <h3>Request a plan, not just the feature/metric</h3>
        <img src="images/query_plan.png" style="border: none;" width=800>
      </section>

      <section data-transition="fade-in">
        <h3>Implementation</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
              
          type QueryImpl: Query[A] => ZStream[Any, Error, A]

          def compile(plan: Ops[Query[A]], f: QueryImpl) = 
            plan match {
              case Leaf(a)          => 
                f(a)
              case Sum(left, right) => 
                compile(left).plus(compile(right), ExecutionStrategy.Parallel)
              case OrElse(left, right) => 
                compile(left).orElse(compile(right))   
            }

        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Execution Trace</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            Push the pathways as a list of `Ops[_]` into the Leaf node.
            
            i.e, change `Ops[A]` to `Ops[(List[Ops[_]], A)]`
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Solution</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
              
          type Trace = List[Ops[_]]

          type QueryImpl: (Query[A], List[Ops[_]]) => ZStream[Any, Error, A]

          def compile(plan: Ops[Query[A]], f: QueryImpl, trace: Trace) = 
            plan match {
              case Leaf(a)          => 
                f(a)
              case a @ Sum(left, right) => 
                compile(left, a :: trace).plus(compile(right, a :: trace), ExecutionStrategy.Parallel)
              case a @ OrElse(left, right) => 
                compile(left, a :: trace).orElse(compile(right, a :: trace))   
            }

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Well I need a depth of each leaf as well?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            
           type QueryImpl: (Query[A], List[Ops[_]], Int) => ZStream[Any, Error, A]

           def compile(plan: Ops[Query[A]], f: QueryImpl, trace: Trace, depth: Int) = ??? 
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Well I need to compute the result of each subcomputation</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            
           Is that top-down or bottom up logic ??

           def compile(
             plan: Ops[Query[A]], 
             f: QueryImpl, 
             trace: Trace, 
             depth: Int, 
             subComputation: Map[Ops[_], ZStream[..]]
          ) = ??? 

          How can I map the `Map` back to the original plan?

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Let's bring in performance at each node as well</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
           type Performance = Long

           def compile(
             plan: Ops[Query[A]], 
             f: QueryImpl, 
             trace: Trace, // Top-Down
             depth: Int,   // Top-Down
             subComputation: Map[Ops[_], ZStream[..]], // Maybe-bottom-up
             subComputation: Map[Ops[_], Long] // Bottom-up?
          ) = ??? 

          How can I map the two `Map`s back to the original plan?

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Let's don't pollute our implementation at all</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            Let's jump into recursion scheme here.
            This is not going to be introduction to recursion scheme.
            For those who are not familiar, I hope its a new thing to learn for you.
            For those who are already familiar, I hope you are learning new with recursion scheme as well.
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Building blocks</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
           fix point of cosine is x if cos(x) = x

        </code></pre>
      </section>

    </div>
  </div>

  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      // ...

      // The "normal" size of the presentation, aspect ratio will be preserved
      // when the presentation is scaled to fit different resolutions. Can be
      // specified using percentage units.
      width: 1300,
      height: 750,

      // Factor of the display size that should remain empty around the content
      margin: 0.1,

      // Bounds for smallest/largest possible scale to apply to content
      minScale: 0.2,
      maxScale: 1.5,
      history: true,
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true },
        { src: 'https://d3js.org/d3.v4.min.js' },
        { src: 'plugin/d3js/d3js.js' }
      ]
    });
  </script>
</body>

</html>