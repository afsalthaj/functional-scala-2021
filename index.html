<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/moon.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/atom-one-dark.css">


  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);

  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <!-- Heading section -->
      <section data-markdown>
        <textarea data-template>
            ## Functionally Designed Application
            ### and making it transparent
	      </textarea>
      </section>


      <section data-markdown>
        <p style="font-size:22px">Thanks John De Goes for being my mentor changing the way I think</p>

        <p style="font-size:22px">Thanks Adam for not sleeping ever </p>

        <p style="font-size:22px">Thanks Sandra for organising the wonderful event, and being there for us </p>

        <p style="font-size:22px">Thanks everyone at Ziverge </p>

        <p style="font-size:22px">And all the sponsors</p>

      </section>



      <section data-transition="fade-out">
        <h3>What to expect </h3>

        <p style="font-size:40px"> An example of <span style="color: tomato;">Functional
            Design</span>
        </p>
        <p style="font-size:40px"> Attribute Grammer + <span style="color: tomato;">Recursion
            Scheme</span></p>
      </section>

      <section data-transition="fade-out">
        <h3>Pre-requisite </h3>
        <p style="text-align: left;"> Some familiarity with the following
        </p>
        <p style="font-size:30px;text-align: left;"><span style="color:tomato;text-align: left;">Functional
            Design</span></p>
        <p style="font-size:30px; text-align: left;"><span style="color: tomato;text-align: left;">Recursion
            Scheme</span></p>
        <p style="font-size:30px; text-align: left;"><span style="color: tomato;text-align: left;">ZIO ecosystem</span>
        </p>

      </section>

      <section data-transition="fade-out">
        <h3>Headsup :) </h3>

        <p style="font-size:35px;text-align: left;"><span>Code intense slides</span></p>
        <p style="font-size:35px;text-align: left;"><span>Intended for future reference</span></p>
        <p style="font-size:35px;text-align: left;"><span>Concepts are backed by academic papers</span></p>
      </section>


      <section data-transition="fade-out">
        <h3>Our usecase, history</h3>

        <p style="font-size:35px;text-align: left;"> Make your platform observable through <span
            style="color: tomato;">metrics
            calculation</span> ;a backend GraphQl service</p>

        <p style="font-size:35px;text-align: left;">Existed in various shapes in <span style="color: tomato;"> different
            data-sources</span>
        </p>
        <p style="font-size:35px;text-align: left;"><span> Weeks to bring a new metrics in production
          </span></p>
        <p style="font-size:35px;text-align: left;">Main reason: <span style="color: tomato;"> Hard to debug; less
            transparency </span></p>

      </section>


      <section data-transition="fade-out">
        <h3>Our usecase, history</h3>

        <p style="font-size:35px;">Code to make things observable was <span style="color: tomato;"> not
            observable </span></p>

      </section>

      <section data-transition="fade-out">
        <h3>Metrics === Customer Attributes === Anything</h3>

        <p style="font-size:35px;"> Calculating metrics, is similar to calculating a customer attribute (feature) for
          instance.</p>



      </section>

      <section data-transition="fade-out">
        <h3>Specific problems</h3>
        <pre><code class="hljs json" style="font-size:25px;" data-trim data-trim>
          
        Data for a feature/metric can exist in multiple sources, at different time
  
        Need to collate the results from various sources
        
        Need to try all the sources and pick the one that wins
        
        + optimisations 

        + transparency

        + track performance

        </code></pre>
      </section>


      <section data-transition="fade-out">
        <h3>That's a common problem indeed</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          
        Infact, we started with a specific problem but essentially
        the problem statement is quite common in our industry.

        </code></pre>
      </section>

      <!-- Slide 2 -->
      <section data-transition="fade-out">
        <h3>How to solve all of these?</h3>
        <pre><code class="hljs scala" style="font-size:22px;">
          
        - An execution plan
        - An execution summary

        where an , execution summary == execution planner + extra details.

        The generic shape of plan and summary are the same - sort of!

        </code></pre>
      </section>

      <!-- Slide 2 -->
      <section data-transition="fade-out">
        <h3>How to solve?</h3>
        <pre><code class="hljs scala" style="font-size:20px;" data-trim data-trim>
         sealed trait Metric[A]

         object Metric {
          case class Source[A](dataSource: DataSource[A])                                 extends Metric[A] 
          case class Ratio[A](numerator: Metric[A], denominator: Metric[A])               extends Metric[A]
          case class Sum[A](left: Metric[A], right: Metric[A])                            extends Metric[A]
          case class OrElse[A](left: Metric[A], right: Metric[A])                         extends Metric[A]
          case class Within[A](metric: Metric[A], start: RelativeTime, end: RelativeTime) extends Metric[A]
         }
      
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Relative Time</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim>
     sealed trait RelativeTime
       
     object RelativeTime {
       final case object Now                          extends RelativeTime
       final case object Epoch                        extends RelativeTime
       final case class BeforeNow(duration: Duration) extends RelativeTime
     }

        </code></pre>
      </section>


      <!-- Slide 3 -->

      <section data-transition="fade-in">
        <h3>DataSource</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim>
          sealed trait DataSource[A] 

          object DataSource {
            final case class Empty[A]()                         extends DataSource[A]
            final case class AwsS3[A](metricName: String)       extends DataSource[A]
            final case class Postgres[A](from: AuroraLogic[A])  extends DataSource[A]
            final case class InMemoryCache[A]()                 extends DataSource[A]
          }

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Add a new metric/feature in code</h3>
        <pre><code class="hljs scala" style="font-size:26px;" data-trim>
         
          def fromPostgres[A](expr: Expr[A]) = 
            Source(DataSource.aurora(expr)))

          def fromS3(metricName: String) = 
            Source(DataSource.awsS3(metricName))

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Add a new metric/feature in code</h3>
        <pre><code class="hljs scala" style="font-size:24px;" data-trim="">
         
          val myNewMetric = 
            fromPostgres(sum(int("time_taken")).from(table"x"))
             .within(now, beforNow(6.hours))
             .orElse(fromS3("total_time_taken")
             .within(epoch, beforeNow(6.hours)))

        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Add a new metric/feature in code</h3>
        <pre><code class="hljs scala" style="font-size:24px;" data-trim data-trim>
          // And internally

          val updatedMetric = 
            Source(InMemoryCache()).orElse(myNewMetric)

         // All of these are just data   

        </code></pre>
      </section>

      <!-- Slide 4 -->

      <section data-transition="fade-in">
        <h3>Ok, what's the end to end flow?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
          Request[A] => Metric[A]
          Metric[A]  => ZStream[Any, Error, A]  ???
          
          Hmmm..not really, coz there are more abstractions in place
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Query</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
          // We need to represent the operations done at each datasource level
          sealed trait Query[A]

          object Query {
            final case class FromCache[A](input: DataSource[_], window: Window) extends Query[A]
            final case class FromS3[A](request: S3.Request) extends Query[A]
            sealed trait SqlQuery[A] extends Query[A]
            object SqlQuery {}
          }

        </code></pre>
      </section>

      <!-- Slide 5-->
      <section data-transition="fade-in">
        <h3>Sql Query</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim>
          final case class Select[A](expr: Expr[A])                           extends SqlQuery[A]
          final case class From[A](q1: SqlQuery[A], q2: SqlQuery[A])          extends SqlQuery[A]
          final case class Filter[A](query: SqlQuery[A], expr: Expr[Boolean]) extends SqlQuery[A]
          final case class GroupBy[A, B](query: SqlQuery[A], expr: Expr[B])   extends SqlQuery[A] 
          final case class InnerJoin[A, B](q1: SqlQuery[A], q2: SqlQuery[B])  extends SqlQuery[A]

          // Skipped some details
        </code></pre>
      </section>

      <!-- Slide 5-->

      <section data-transition="fade-in">
        <h3>Ok, what's the end to end flow now?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
          Request[A] => Metric[A]
          Metric[A]  => Query[A] 
          Query[A]   => ZStream[Any, Error, A] ???

          Hmmm..not really, coz there is 1 more abstraction in place
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Execution Plan</h3>
        <pre><code class="hljs scala" style="font-size:20px;" data-trim data-trim >
  sealed trait Ops[A]

  object Ops {
    final case class Noop[A](query: A)                                             extends Ops[A]
    final case class Sum[A](opss: NonEmptyChunk[Ops[A]], exec: ExecutionStrategy)  extends Ops[A]
    final case class Partial[A](ops: Ops[A)                                        extends Ops[A]
    final case class Union[A](left: Ops[A], right: Ops[A])                         extends Ops[A]
    final case class Fail[A](message: String)                                      extends Ops[A]
    final case class OrElse[A](self: Ops[A], that: Ops[A])                         extends Ops[A]
  }

        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Ok, What's the flow now please?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
          Request[A]                  => Metric[A]
          Metric[A]                   => Ops[Query[A]] 
          Ops[Query[A]]               => Ops[ZStream[Any, Error, A]]
          Ops[ZStream[Any, Error, A]] => ZStream[Any, Error, A]

          Woo, finally!
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>How to form the plan?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1">
          def plan(request: Request[A]): Ops[Query[A]] = {
            request.metric match {
              case Metric.Within(metric, start, end) => 
                val requested = request.window
                val available = Window(start.toInstant(now), end.toInstant(now))

              if (requested.isSubsetOf(available)) {
                plan(request.withMetric(metric)).map(_.withWindow(requested))
              } else if (requested.isNotIn(available)) {
                Ops.Fail("The metric is not available in the data-source")
              } else {
                Ops.Partial(plan(request.withMetric(metric).withWindow(requested.intersect(available))))
              }    
            }
          }
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>How to form the plan?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="2-5">
          def plan(request: Request[A]): Ops[Query[A]] = {
            request.metric match {
              case Metric.Within(metric, start, end) => 
                val requested = request.window
                val available = Window(start.toInstant(now), end.toInstant(now))

              if (requested.isSubsetOf(available)) {
                plan(request.withMetric(metric)).map(_.withWindow(requested))
              } else if (requested.isNotIn(available)) {
                Ops.Fail("The metric is not available in the data-source")
              } else {
                Ops.Partial(plan(request.withMetric(metric).withWindow(requested.intersect(available))))
              }    
            }
          }
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>How to form the plan?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="6-8">
          def plan(request: Request[A]): Ops[Query[A]] = {
            request.metric match {
              case Metric.Within(metric, start, end) => 
                val requested = request.window
                val available = Window(start.toInstant(now), end.toInstant(now))

              if (requested.isSubsetOf(available)) {
                plan(request.withMetric(metric)).map(_.withWindow(requested))
              } else if (requested.isNotIn(available)) {
                Ops.Fail("The metric is not available in the data-source")
              } else {
                Ops.Partial(plan(request.withMetric(metric).withWindow(requested.intersect(available))))
              }    
            }
          }
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>How to form the plan?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="9-10">
          def plan(request: Request[A]): Ops[Query[A]] = {
            request.metric match {
              case Metric.Within(metric, start, end) => 
                val requested = request.window
                val available = Window(start.toInstant(now), end.toInstant(now))

              if (requested.isSubsetOf(available)) {
                plan(request.withMetric(metric)).map(_.withWindow(requested))
              } else if (requested.isNotIn(available)) {
                Ops.Fail("The metric is not available in the data-source")
              } else {
                Ops.Partial(plan(request.withMetric(metric).withWindow(requested.intersect(available))))
              }    
            }
          }
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>How to form the plan? An example</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="11-14">
          def plan(request: Request[A]): Ops[Query[A]] = {
            request.metric match {
              case Metric.Within(metric, start, end) => 
                val requested = request.window
                val available = Window(start.toInstant(now), end.toInstant(now))

              if (requested.isSubsetOf(available)) {
                plan(request.withMetric(metric)).map(_.withWindow(requested))
              } else if (requested.isNotIn(available)) {
                Ops.Fail("The metric is not available in the data-source")
              } else {
                Ops.Partial(plan(request.withMetric(metric).withWindow(requested.intersect(available))))
              }    
            }
          }
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>How to form the plan? An example</h3>
        <pre><code class="hljs scala" style="font-size:20px;" data-trim data-trim>

          case MetricDsl.OrElse(m1, m2) =>
            (plan(request.withMetric(m1)), plan(request.withMetric(m2))) match {
              // Skipped a few others
              case (Ops.Partial(query1, w1, _), Ops.Partial(query2, w2, _)) => Ops.Union(query1, w1, query2, w2)
              case (ops1, ops2)                                             => Ops.OrElse(ops1, request.window, ops2, request.window)
            }
        </code></pre>
      </section>


      <!-- Slide -->
      <section data-transition="fade-out">
        <h3>Metric was Data, and ExecPlan is Data too</h3>

        That was your execution plan, done!

      </section>

      <section data-transition="fade-in">
        <h3>Pretty Printing it is easy</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-20">
        def toJson[A](f: A => Json, plan: Ops[A]): Json =
          plan match {
            case Ops.Noop(a) =>
              f(a)
    
            case Ops.Partial(ops, _, _) =>
              Json.Obj(Chunk(("partial", ops.toJson(f))))
    
            case Ops.Fail(err) =>
              Json.Obj(Chunk(("fail", Json.Str(err))))
    
            case Ops.Sum(chunk, _) =>
              Json.Obj(Chunk(("sum", Json.Arr(chunk.map(_.toJson(f))))))
    
            ....
    
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Execution Plan: Ops[Query[A]]</h3>
        <pre><code class="hljs json" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
      "union": [
        {"fall-back": [
          "request-cache-metric-name-for-time-2021-09-16T08:27:28Z-and-2021-09-1608:31:00Z",
          "request-database-SELECT value, COUNT(DISTINCT(abc.def)) FROM my_Table where time > '2021-09-16T08:27:28Z' AND time < '2021-09-16T08:29:00Z "
          ]
        },
        {"fall-back": [
          "request-cache-AWSS3(my_metric_name)",
            { "sum": [
                "request-aws-s3:Request(2021,9,16,8,Some(30),List(my_metric_name),location)",
                "request-aws-s3:Request(2021,9,16,8,Some(31),List(my_metric_name),location)"
              ]
            }
          ]
        }
      ]
        </code></pre>
      </section>

      <!-- Slide -->
      <section data-transition="fade-in">
        <h3>Request a plan - Transparency 101</h3>
        <img src="images/query_plan.png" style="border: none;" width=800>
      </section>

      <section data-transition="fade-in">
        <h3>Convert the plan to something real ?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
              
          type QueryImpl: Query[A] => ZStream[Any, Error, A]

          def compile(plan: Ops[Query[A]], f: QueryImpl): ZStream[Any, Error, A] = 
            plan match {
              case Leaf(a)          => 
                f(a)  
              case Sum(left, right) => 
                compile(left).plus(compile(right), ExecutionStrategy.Parallel)
              case OrElse(left, right) => 
                compile(left).orElse(compile(right))   
            }

        </code></pre>
      </section>

      <!-- Slide 2 -->
      <section data-transition="fade-out">
        <h3>Where are we now?</h3>
        <pre><code class="hljs scala" style="font-size:22px;">
        
      - An execution plan    : DONE
      - An execution summary : TODO

      </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Execution Trace</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
            
          When and why did it hit a datasource? 

          Answer: 

          Make stack of (List[Ops[_]]) that led to leaf node 
          available at the leaf node (Ops.Noop),
            
          i.e, change `Ops[A]` to `Ops[(List[Ops[_]], A)]`
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Solution</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim >
              
          type Trace = List[Ops[_]]

          type QueryImpl: (Query[A], Trace) => ZStream[Any, Error, A]

          def compile(plan: Ops[Query[A]], f: QueryImpl, trace: Trace) = 
            plan match {
              case Leaf(query)          => 
                f(query, trace)
              case a @ Sum(left, right) => 
                compile(left, a :: trace).plus(compile(right, a :: trace), ExecutionStrategy.Parallel)
              case a @ OrElse(left, right) => 
                compile(left, a :: trace).orElse(compile(right, a :: trace))   
            }

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Well I need a depth of each leaf as well?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim >
            
           type QueryImpl: (Query[A], List[Ops[_]], Int) => ZStream[Any, Error, A]

           def compile(plan: Ops[Query[A]], f: QueryImpl, trace: Trace, depth: Int) = ??? 
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Well I need to access the result of each subcomputation too?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
            
           Is that top-down or bottom up logic ??

           def compile(
             plan: Ops[Query[A]], 
             f: QueryImpl, 
             trace: Trace, 
             depth: Int, 
             subComputation: Map[Ops[_], ZStream[..]]
          ) = ??? 

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>And performance?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
           type Performance = Long

           def compile(
             plan: Ops[Query[A]], 
             f: QueryImpl, 
             trace: Trace, // Top-Down
             depth: Int,   // Top-Down
             subComputation: Map[Ops[_], ZStream[..]], // Maybe-bottom-up
             execTimes: Map[Ops[_], Long] // Bottom-up?
          ) = ??? 

          How can I map all these `Map`s to "orginal plan with extra details" ?

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Let's dont pollute implementations</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
          Let's dont pollute implementations
          N, let's don't bring too many data-structures

          - Let's begin recursion scheme (not an intro)
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
            
        final case class class Fix[F[_]](unfix: F[Fix[F]])
        
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
            
        sealed trait Ops[A]

        case class Noop[A](query: A) e                    extends Ops[A]
        case class Sum[A](left: Ops[A], right: Ops[A])    extends Ops[A]
        case class OrElse[A](left: Ops[A], right: Ops[A]) extends Ops[A]
        
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
            
        sealed trait OpsF[A, B]

        case class LeafF[A, B](query: A)         extends OpsF[A, B]
        case class SumF[A, B](left: B, right: B) extends OpsF[A, B]

        // Skipping other nodes intentionally 
        // Also u need a bifunctor instance to be able to map both A and B
        // of which mapping B is going to be used for playing with recursion scheme
        
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
            
         type Ops[A] = Fix[Ops[A, *]]
        
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;">
            
    cata: F[A]             => A => Fix[F] => A
    
    para: F[(Fix[F], A)]   => A => Fix[F] => A
   
    histo: F[Cofree[F, A]] => A => Fix[F] => A
        
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;">
            
    cata: F[V, A]                => A => Fix[F[V, *]] => A
    
    para: F[(Fix[F[V, *]], A)]   => A => Fix[F[V, *]] => A
         
    histo: F[Cofree[F[V, *], A]] => A => Fix[F[V, *]] => A

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:20px;">

    def cata[F[_, _], V, A](algebra: F[V, A] => A)(implicit B: BiFunctor[B]): Fix[F[V, *]] => A =
      fix => algebra(B.second(fix.unfix)(cata.apply(_)(algebra)))

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>But.. Why?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
          Tracing was actually pushing some attributes down the children from parents.
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>But.. Why?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
          Tracing is present bottom up too. But then you need to pass it down again to children again.
          Leading us to the terminologies in Attribute Grammer
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Attribute Grammer</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
          type Algebra[F[_], A] = 
            F[A] => A

          type AttAlgebra[F[_], I, S, A] = 
            F[I => (S, A)] => I => (S, A)

         // https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.460.4909&rep=rep1&type=pdf
         // https://wiki.haskell.org/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter   

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Oh, you mean folding to a function? </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
          // Yes, but a bit of formalisation is essential here.
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Let's make our cata specific to attribute grammers </h3>
        <pre><code class="hljs scala" style="font-size:15px;" data-trim data-trim>
   
        // Only for explanations
        type TraceAlgebra[F[_], I, D] = F[I => S] => I => S
        type Algebra[F[_], A]         = F[A]      => A

        def cata[F[_, _], V, A](algebra: Algebra[F[V, *], A])(implicit B: BiFunctor[FromS3]): Fix[F[V, *]] => A =
          fix => algebra(B.second(fix.unfix)(cata(_)(algebra)))
    
        def cataTrace[F[_, _], V, I, S](algebra: TraceAlgebra[F[V, *], I, S])(implicit B: BiFunctor[F]): Fix[F[V, *]] => (I => S) = { 
          fix => algebra(B.second(fix.unfix)(cataTrace(algebra)(B)(_)))
        }

        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Use cataTrace once and for all</h3>
        <pre><code class="hljs scala" style="font-size:25px;" data-trim data-trim>

          // See Ops[A] here is Fix[OpsF[A, *]]

          def trace[A, B](f: B => B)(zero: B): Ops[A] => Ops[(A, B)] = {
            val algebra: OpsF[A, B => Ops[(A, B)]] => B => Ops[(A, B)] = {
              {
                // fb1 and fb2 is B => Ops[(A, B)]
                case SumF(fb1, fb2) => b => Fix(SumF(fb1(f(b)), fb2(f(b))))
                case LeafF(n)       => b => Fix(LeafF((n, b)))
              }
            }
        
            ops =>  cataTrace(algebra)(ops)(f(zero))
          }
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>An example </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>
          val plan0 = 
            sum(leaf("query1")), leaf("query2"))
         
          val plan =
            sum(plan0, leaf("query3"))

          println(plan)
          // Fix(NodeF(Fix(NodeF(Fix(LeafF((afsal,3))),Fix(LeafF((thaj,3))))),Fix(LeafF((thaj2,2)))))  
          
          def withDepth[A](plan: Ops[A]): Ops[(A, Int)] =
            trace(_ + 1)(0)(plan)

          withDepth(plan)  

         // Fix(NodeF(Fix(NodeF(Fix(LeafF((query1, 3))),Fix(LeafF((query2, 3))))),Fix(LeafF((query3, 2)))))

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Attribute Grammer with Paramorphism</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>

          def paraTrace[F[_, _], V, I, D](
            f: F[V, (Fix[F[V, *]], I => D)] => I => D
          ): Fix[F[V, *]] => (I => D) = ???

          def trace[A, B](f: B => B)(zero: B)                   : Ops[A] => Ops[(A, B)] = ???
          def trace[A, B](f: (Fix[OpsF[A, *]], B) => B)(zero: B): Ops[A] => Ops[(A, B)] = ???
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Attribute Grammer with Paramorphism </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>

          // Para has the history of previous computation inputs, so a small change
          
          def trace[A, B](f: (Fix[OpsF[A, *]], B) => B)(zero: B): Ops[A] => Ops[(A, B)] = {
            val algebra: OpsF[A, (Fix[OpsF[A, *]], B => Ops[(A, B)])] => B => Ops[(A, B)] = {
              {
                case SumF((his1, fb1), (his2, fb2)) => b => Fix(SumF(fb1(f(his1, b)), fb2(f(his2, b))))
                case LeafF(n)                       => b => Fix(LeafF((n, b)))
              }
            }
        
              ops => paraTrace(byDepthF)(ops)(f(ops, zero))
            }
          }

        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Tracing done </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>

        type Trace[A] = List[Fix[OpsF[A, *]]]

        def withDepth[A](ops: Ops[A]): Ops[(A, Int)] =
          trace((_, depth) => depth + 1)(0)(ops)
  
        def withTrace[A](ops: Ops[A]): Ops[(A, Trace[A])] =
          trace[A, Trace[A]](_ :: _)(Nil)(ops)

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>And we can compose independently</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>

          type Ops[A] = Fix[OpsF[A, *]]

          val ops0: Ops[Int] =
            ratio(leaf(20), leaf(30)))

          val ops: Ops[Int] =
            sum(ops0, leaf(10))

          println(withDepth(ops))
          println(withTrace(ops))
          println(withDepth(withTrace(ops)))


        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Program without attributes</h3>
        <pre><code class="hljs json" style="font-size:22px;" data-trim data-trim>

          {
            "sum": [
              {
                "ratio": [
                  20,
                  30
                ]
              },
              10
            ]
          }

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Program with all the attributes</h3>
        <pre><code class="hljs json" style="font-size:22px;" data-trim data-trim>
          {
            "sum": [
              {
                "ratio": [
                  {
                    "value": 20,
                    "depth": 3,
                    "trace": [
                      {"value": 20},
                      {"ratio": [{"value": 20},{ "value": 30 }]},
                      {"sum": [{"ratio": [{"value": 20},{"value": 30}]},{ "value": 10 }]}
                    ]
                  },
                  {
                    "value": 30,
                    "depth": 3,
                    "trace": [
                      {"value": 30},
                      {"ratio": [{"value": 20},{"value": 30}]},
                      {"sum": [{"ratio": [{"value": 20},{"value": 30}]},{"value": 10}]}
                    ]
                  }
                ]
              },
              {
                "value": 10,
                "depth": 2,
                "trace": [
                  {"value": 10},
                  {"sum": [{"ratio": [{"value": 20},{"value": 30}]},{"value": 10}]}
                ]
              }
            ]
          }

        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Track SubComputation Results</h3>
        <pre><code class="hljs scala" style="font-size:22px;">

         final case class Fix[F[_]](unfix: F[Fix[F]])


        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Track SubComputation Results</h3>
        <pre><code class="hljs scala" style="font-size:22px;">

         // For each F, annotate it with results
         final case class Fix[F[_]](unfix: F[Fix[F]])

         
        </code></pre>
      </section>



      <section data-transition="fade-in">
        <h3>Track SubComputation Results - Progress Results </h3>
        <pre><code class="hljs scala" style="font-size:22px;">
         // For eac OpsF, annotate it with the result, 
         final case class Compose[F[_], G[_], A](value: F[G[A]]])
         final case class Fix[F[_]](unfix: F[Fix[F]])

         type Ops[A]                = Fix[OpsF[A, *]]
         type AnnotatedResult[A, R] = Fix[Compose[(R, *), OpsF[A, *], *]]   
        </code></pre>
      </section>



      <section data-transition="fade-in">
        <h3>Track SubComputation Results</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim>

         // Let's replace Compose with Cofree
         final case class Cofree[F[_], R](result: R, value: F[Cofree[F]])
         final case class Fix[F[_]](unfix: F[Fix[F]])

         type AnnotatedResult[A, R] = Cofree[OpsF[A, *], R]]
         
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Strategy</h3>

        <p style="font-size:22px">Let's have a version of cata that produces Cofree[F, A] instead of A</p>

        <pre><code class="hljs scala" style="font-size:20px;">

  def cata [F[_, _], V, A] (step: Algebra[F[V, *], A]): Fix[F[V, *]] => A

  def cataCF[F[_, _], V, A](step: Algebra[F[V, *], A]): Fix[F[V, *]] => Cofree[F[V, *], A] = ???
         
         
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Strategy</h3>

        <pre><code class="hljs scala" style="font-size:19px;" data-trim data-trim data-line-numbers="2-5">

          def cataCF[F[_, _]: BiFunctor, V, A](step: Algebra[F[V, *], A]): Fix[F[V, *]] => Cofree[F[V, *], A] = fix => {     
            val algebra: F[V, Cofree[F[V, *], A]] => Cofree[F[V, *], A] =
              fCofree => Cofree(step(fCofree.second(_.value)), fCofree)
        
            cata(algebra)(fix)
          }
         
         
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Call cataCF instead of cata and no change</h3>
        <pre><code class="hljs scala" style="font-size:20px;" data-trim data-trim>
          def compile[A](f: Query[A] => OutputStream): Algebra[OpsF[Query[A], *], OutputStream] = ???

          val simpleResult = 
           cata(compile, plan)

         // zio.stream.ZStream$$anon$1@3d74bf60             

          val subComputationResult = 
           cataCF(compile, plan)
           
         // Cofree(
         //   zio.stream.ZStream$$anon$1@3d74bf60,
         //   Sum(
         //     Cofree(zio.stream.ZStream$$anon$1@4f209819, Leaf(query1)),
         //     Cofree(zio.stream.ZStream$$anon$1@15eb5ee5, Leaf(query2))
         //   )
         //)  
  
         
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>We already solved performance of sub computation</h3>
        <pre><code class="hljs scala" style="font-size:20px;" data-trim data-trim>
          // The name `step` was intentional
          def cataCF[F[_, _], V, A](
            step: Algebra[F[V, *], A]
         ): Fix[F[V, *]] => Cofree[F[V, *], A] = ???
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>We already solved performance of sub computation</h3>
        <pre><code class="hljs scala" style="font-size:20px;" data-trim data-trim>
          def compile[A]: Algebra[OpsF[Query[A], *], OutputStream] = ???
      
          def withSubComputationResults = 
            cataCF(algebra, plan)

          val withLog = 
            cataCF(fa => log.info("Running ${fa}") *> compile(fa) <* log.info("Done"), plan)

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Annotate with result with performance</h3>
        <pre><code class="hljs scala" style="font-size:20px;" data-trim data-trim>
          def unzip(f: OpsF[(A, B)]): (Ops[A], Ops[B]) = ???  

          val cofree = 
            cataCF(fa => {
              val execTime = new AtomicLong(0)
          
              val stream = ZStream.fromEffect {
                ZIO.effectTotal(System.nanoTime())
              }.flatMap(start => {
                compile(fa)(unzip(fa)).ensuring(
                  ZIO.effectTotal(System.nanoTime()).map(end => {
                    execTime.set(end - start)
                  })
                )
              })

            (execTime, stream)

          }, plan)

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Program with all the attributes</h3>
        <pre><code class="hljs json" style="font-size:22px;" data-trim data-trim>
         
          val result = zio.Runtime.Default.unsafeRun(cofree.value._1.run(ZSink.collectAll))
          println(cofree.map(_._2))

          Cofree(
            8617392225,
            Sum(
              Cofree(8589524370, Leaf(query1)),
              Cofree(8591958288, Leaf(query2))
            )
          )  
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Summary of what we did</h3>
        <pre><code class="hljs json" style="font-size:22px;" data-trim data-trim>
         1. Real life example of a functionally designed code
         2. Making execution plan available
         3. Making any kind of execution summary available with 
            - A Fix and Cofree case class
            - And 3 methods; para, paraTraceAttributeGrammer and cataCF
  
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>References</h3>
        <pre><code class="hljs json" style="font-size:22px;" data-trim data-trim>
         1. https://www.reddit.com/r/haskell/comments/8eidw7/recursion_schemes_with_bifunctors/?utm_source=share&utm_medium=ios_app&utm_name=iossmf
         2. https://ris.utwente.nl/ws/files/6142049/meijer91functional.pdf
         3. https://blog.sumtypeofway.com/posts/recursion-schemes-part-4.html (Haskell)
         4. https://www.reddit.com/r/haskell/comments/8mpo1x/recursion_scheme_question_tracing/
         5. https://youtu.be/Zw9KeP3OzpU?t=3263 
         6. A paper on Attribute Grammers in Functional Style
              https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.460.4909&rep=rep1&type=pdf
        </code></pre>
      </section>

    </div>
  </div>

  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      // ...

      // The "normal" size of the presentation, aspect ratio will be preserved
      // when the presentation is scaled to fit different resolutions. Can be
      // specified using percentage units.
      width: 1300,
      height: 750,

      // Factor of the display size that should remain empty around the content
      margin: 0.1,

      // Bounds for smallest/largest possible scale to apply to content
      minScale: 0.2,
      maxScale: 1.5,
      history: true,
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true },
        { src: 'https://d3js.org/d3.v4.min.js' },
        { src: 'plugin/d3js/d3js.js' }
      ]
    });
  </script>
</body>

</html>