<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/moon.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/atom-one-dark.css">


  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);

  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <!-- Heading section -->
      <section data-markdown>
        <textarea data-template>
            ## Make your App Transparent
	      </textarea>
      </section>


      <section data-transition="fade-out">
        <h3>What to expect in this talk? </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          Basic Functional Desgin
          Attribute Grammer
          Recursion Schemes
        </code></pre>
      </section>



      <section data-transition="fade-out">
        <h3>Our usecase: An app to make platform transparent</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          Make your platform observable through metrics with a metrics UI
          There existed a service that runs in the backend to calculate these metrics
          Metrics existed in various shapes in different sources
          Took days or even weeks to bring this metrics in production
        </code></pre>
      </section>


      <section data-transition="fade-out">
        <h3>Metrics calculation</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          
        1. Data for a feature/metric can exist in multiple sources.
        2. At different time periods - union 
        3. Or even you need to try multiple sources
        4. + optimisations 

        </code></pre>
      </section>


      <section data-transition="fade-out">
        <h3>Metrics calculation</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          
        1. When you ask the service for a metric, can it emit a plan on what to execute?
        2. Can it then emit a summary of the details of executed computation ? 

        </code></pre>
      </section>

      <section data-transition="fade-out">
        <h3>Analytics Engine</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          
        Infact, we started with a specific problem but essentially
        the problem statement is quite common in our industry.

        </code></pre>
      </section>

      <!-- Slide 2 -->
      <section data-transition="fade-out">
        <h3>How to solve?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          
        An execution planner
        An execution summary

        </code></pre>
      </section>

      <!-- Slide 2 -->
      <section data-transition="fade-out">
        <h3>How to solve?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
         // In our case we need to be able to define a metric
         sealed trait Metric[A]

         object Metric {
          case class Source[A](dataSource: DataSource[A])                     extends Metric[A] 
          case class Ratio[A](numerator: Metric[A], denominator: Metric[A])   extends Metric[A]
          case class Sum[A](left: Metric[A], right: Metric[A])                extends Metric[A]
          case class OrElse[A](left: MetricDsl[A], right: MetricDsl[A])       extends MetricDsl[A]
          case class Within[A](metric: Metric[A], start: RelativeTime, end: RelativeTime) extends Metric[A]
         }
      
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>DataSource</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
     sealed trait RelativeTime
       
     object RelativeTime {
       final case object Now                          extends RelativeTime
       final case object Epoch                        extends RelativeTime
       final case class BeforeNow(duration: Duration) extends RelativeTime
       final case class At(instant: Instant)          extends RelativeTime
     }

        </code></pre>
      </section>


      <!-- Slide 3 -->

      <section data-transition="fade-in">
        <h3>DataSource</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          sealed trait DataSource[A] 

          object DataSource {
            final case class Empty[A]()                                  extends DataSource[A]
            final case class AwsS3[A](metricName: String)                extends DataSource[A]
            final case class Postgres[A](from: AuroraLogic[A])           extends DataSource[A]
            final case class InMemoryCache[A](dataSource: DataSource[A]) extends DataSource[A]
          }

        </code></pre>
      </section>

      <!-- Slide 4 -->

      <section data-transition="fade-in">
        <h3>Query</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          // We need to represent the operations done at each datasource level
          sealed trait Query[A]

          object Query {
            final case class FromCache[A](input: DataSource[_], window: Window) extends Query[A]
            final case class FromS3[A](request: S3.Request) extends Query[A]
            sealed trait SqlQuery[A] extends Query[A]
            object SqlQuery {
              ....

            }

          }

        </code></pre>
      </section>

      <!-- Slide 5-->
      <section data-transition="fade-in">
        <h3>Sql Query</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          final case class Select[A](expr: Expr[A]) extends SqlQuery[A]
          final case class From[A](q1: SqlQuery[A], q2: SqlQuery[A]) extends SqlQuery[A]
          final case class Filter[A](query: SqlQuery[A], expr: Expr[Boolean]) extends SqlQuery[A]
          final case class GroupBy[A, B](query: SqlQuery[A], expr: Expr[B]) extends SqlQuery[A] 
          final case class InnerJoin[A, B](q1: SqlQuery[A], q2: SqlQuery[B], onLeft: String, onRight: String) extends SqlQuery[A]
        </code></pre>
      </section>

      <!-- Slide 5-->
      <section data-transition="fade-in">
        <h3>Execution Plan</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
           An abstraction that is closer to the implementation
           That's called Ops
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Execution Plan</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
  sealed trait Ops[A]

  object Ops {
    final case class Noop[A](query: A) extends Ops[A]
    final case class Partial[A](ops: Ops[A], forWindow: Window, remainingWindow: Window) extends Ops[A]
    final case class Union[A](left: Ops[A], leftWindow: Window, right: Ops[A], rightWindow: Window) extends Ops[A]
    final case class Fail[A](message: String) extends Ops[A]
    final case class Sum[A](nonEmptyChunk: NonEmptyChunk[Ops[C, A]], executionStrategy: Option[ExecutionStrategy] = None) extends Ops[A]
    final case class OrElse[A](self: Ops[C, A], leftWindow: Window, that: Ops[C, A], rightWindow: Window) extends Ops[A]
  }

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Program Flow</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          Request                 => Ops[Query[(String, A)]]
          Ops[Query[(String, A)]] => Ops[ZStream[Any, Error, (String, A)]]
          Ops[ZStream[Any, Error, (String, A)]] => ZStream[Any, Error, (String, A)]
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Execution Flow</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-20">
          def plan(request: Request[A]): Ops[Query[(String, A)]] = {
            request.metric match {
              case Metric.Within(metric, start, end) => 
                val requested = request.window
                val available = Window(start.toInstant(now), end.toInstant(now))

              if (requested.isSubsetOf(available)) {
                plan(request.withMetric(metric)).map(_.withWindow(requested))
              } else if (requested.isNotIn(available)) {
                Ops.Fail("The metric is not available in the data-source")
              } else {
                Ops.Partial(plan(request.withMetric(metric).withWindow(requested.intersect(available))))
              }    
            }
          }
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Execution Flow</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-20">
          
          case MetricDsl.OrElse(m1, m2) =>
            (plan(request.withMetric(m1)), plan(request.withMetric(m2))) match {
              // Skipped a few others
              case (Ops.Partial(query1, w1, _), Ops.Partial(query2, w2, _)) => Ops.Union(query1, w1, query2, w2)
              case (ops1, ops2)                                             => Ops.OrElse(ops1, request.window, ops2, request.window)
            }
        </code></pre>
      </section>


      <!-- Slide -->
      <section data-transition="fade-out">
        <h3>Metric was Data, and ExecPlan is Data too</h3>

        Well that's your plan, which is Ops[Query[A]]

      </section>

      <section data-transition="fade-in">
        <h3>Pretty Printing it is easy</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-20">
          case MetricDsl.OrElse(m1, m2) =>
            (plan(request.withMetric(m1)), plan(request.withMetric(m2))) match {
              // Skipped a few others
              case (Ops.Partial(query1, w1, _), Ops.Partial(query2, w2, _)) => Ops.Union(query1, w1, query2, w2)
              case (ops1, ops2)                                             => Ops.OrElse(ops1, request.window, ops2, request.window)
            }
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Pretty Printing it is easy</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-20">
        def toJson(f: B => Json): Json =
          plan match {
            case Ops.Noop(query) =>
              f(query)
    
            case Ops.Partial(ops, _, _) =>
              Json.Obj(Chunk(("partial", ops.toJson(f))))
    
            case Ops.Fail(err) =>
              Json.Obj(Chunk(("fail", Json.Str(err))))
    
            case Ops.Sum(chunk, _) =>
              Json.Obj(Chunk(("sum", Json.Arr(chunk.map(_.toJson(f))))))
    
            ....
    
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Execution Plan: Ops[Query[A]]</h3>
        <pre><code class="hljs json" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
      "union": [
        {"fall-back": [
          "request-cache-metric-name-for-time-2021-09-16T08:27:28Z-and-2021-09-1608:31:00Z",
          "request-database-SELECT value, COUNT(DISTINCT(abc.def)) FROM my_Table where time > '2021-09-16T08:27:28Z' AND time < '2021-09-16T08:29:00Z "
          ]
        },
        {"fall-back": [
          "request-cache-AWSS3(my_metric_name)",
            { "sum": [
                "request-aws-s3:Request(2021,9,16,8,Some(30),List(my_metric_name),location)",
                "request-aws-s3:Request(2021,9,16,8,Some(31),List(my_metric_name),location)"
              ]
            }
          ]
        }
      ]
        </code></pre>
      </section>

      <!-- Slide -->
      <section data-transition="fade-in">
        <h3>Request a plan, not just the feature/metric</h3>
        <img src="images/query_plan.png" style="border: none;" width=800>
      </section>

      <section data-transition="fade-in">
        <h3>Implementation</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
              
          type QueryImpl: Query[A] => ZStream[Any, Error, A]

          def compile(plan: Ops[Query[A]], f: QueryImpl) = 
            plan match {
              case Leaf(a)          => 
                f(a)
              case Sum(left, right) => 
                compile(left).plus(compile(right), ExecutionStrategy.Parallel)
              case OrElse(left, right) => 
                compile(left).orElse(compile(right))   
            }

        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Execution Trace</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            Push the pathways as a list of `Ops[_]` into the Leaf node.
            
            i.e, change `Ops[A]` to `Ops[(List[Ops[_]], A)]`
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Solution</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
              
          type Trace = List[Ops[_]]

          type QueryImpl: (Query[A], List[Ops[_]]) => ZStream[Any, Error, A]

          def compile(plan: Ops[Query[A]], f: QueryImpl, trace: Trace) = 
            plan match {
              case Leaf(a)          => 
                f(a)
              case a @ Sum(left, right) => 
                compile(left, a :: trace).plus(compile(right, a :: trace), ExecutionStrategy.Parallel)
              case a @ OrElse(left, right) => 
                compile(left, a :: trace).orElse(compile(right, a :: trace))   
            }

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Well I need a depth of each leaf as well?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            
           type QueryImpl: (Query[A], List[Ops[_]], Int) => ZStream[Any, Error, A]

           def compile(plan: Ops[Query[A]], f: QueryImpl, trace: Trace, depth: Int) = ??? 
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Well I need to compute the result of each subcomputation</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            
           Is that top-down or bottom up logic ??

           def compile(
             plan: Ops[Query[A]], 
             f: QueryImpl, 
             trace: Trace, 
             depth: Int, 
             subComputation: Map[Ops[_], ZStream[..]]
          ) = ??? 

          How can I map the `Map` back to the original plan?

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Let's bring in performance at each node as well</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
           type Performance = Long

           def compile(
             plan: Ops[Query[A]], 
             f: QueryImpl, 
             trace: Trace, // Top-Down
             depth: Int,   // Top-Down
             subComputation: Map[Ops[_], ZStream[..]], // Maybe-bottom-up
             subComputation: Map[Ops[_], Long] // Bottom-up?
          ) = ??? 

          How can I map the two `Map`s back to the original plan?

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Let's don't pollute our implementation at all</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            Let's jump into recursion scheme here.
            This is not going to be introduction to recursion scheme, but we will refresh.
            For those who are not familiar, I hope its a new thing to learn for you.
            For those who are already familiar, I still hope there will be something new for you here.
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Building blocks</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
           fix point of cosine is x if cos(x) = x

           If we continuously do cosine of 0 and keep on applying cosine over the result, 
           we end up in a number finally that gets fixed forever. The number is 0.73908513321516067.

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
          
          val factorial: Int => Int =
            n => if (n == 0) 1 else n * factorial(n - 1)

        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
          
          def factorial(f: Int => Int): Int => Int =
            n => if (n == 0) 1 else n * f(n - 1)

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
          
          def almostFactorial(f: Int => Int): Int => Int =
            n => if (n == 0) 1 else n * f(n - 1)

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">

          val factorial: Int => Int =
            almostFactorial(almostFactorial(almostFactorial(.....)))

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">

           factorial = almostFactorial(factorial)
           x         = cos(x)

           fix point of cos             is x
           fix point of almostFactorial is factorial 

           factorial is fix-point of almostFactorial
        
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">

        // fix of almostFactorial = almostFactorial(almostFactoria(...))
        def fix(fn: Fn) = Fn(fix(fn)) 
        
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            
        final case class class Fix[F[_]](unfix: Fix[F])
        
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            
        sealed trait Ops[A]

        case class Noop[A](query: A) extends Ops[A]
        case class Sum[A](left: Ops[A], right: Ops[A]) extends Ops[A]
        case class OrElse[A](left: Ops[A], right: Ops[A]) extends Ops[A]
        
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            
        sealed trait OpsF[A, B]

        case class Leaf[A, B](query: A) extends OpsF[A, B]
        case class SumF[A, B](left: B, right: B) extends OpsF[A, B]

        // Skipping other nodes intentionally 
        // Also u need a bifunctor instance to be able to map both A and B
        // of which mapping B is going to be used for playing with recursion scheme
        
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            
         type Ops[A] = Fix[Ops[A, *]]
        
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            
         // cata: F[A] => A => Fix[F] => A
         // para: (Fix[F], A)] => A)
         // histo: F[Cofree[F, A]] => A
        
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
            
         // cata: F[V, A] => A => Fix[F[V, *]] => A 
         // para: (Fix[F[V, *]], A)] => A)         
         // histo: F[V, Cofree[F[V, *], A]] => A    // unused for this talk
        
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Building blocks - Basics</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
          def cata[B[_, _], V, A](fix: Fix[B[V, *]])(algebra: F[B[V, A] => A)(implicit B: BiFunctor[B]): A =
            algebra(B.second(fix.unfix)(cata(_)(algebra)))
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>But.. Why?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
          Tracing was actually pushing some attributes down the children from parents.
          It's top down logic
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>But.. Why?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
          Tracing is present bottom up too. But then you need to pass it down again to children again.
          Leading us to the terminologies in Attribute Grammer
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>But.. Why?</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
         def cata(algebra: Algebra[F, A]): Fix[F] => A = ???
         // where, Algebra = F[A] => A
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Attribute Grammer</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
          type Algebra[F[_], A]                            = F[A] => A
          type AttAlgebra[F[_], Inhertied, Synthesized, A] = F[Inhertied => (Synthesized, A)]

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Oh, you mean folding to a function? </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
          // Yes, but a bit of formalisation is essential here.
          // So that all you need is a blind copy of certain methods in papers into Scala
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Let's make our cata specific to attribute grammers </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
   
        // Only for explanations
        type TraceAlgebra[F[_], I, D] = F[I => D] => I => D
        type Algebra[F[_], A]         = F[A]      => A

        def cata[B[_, _], V, A](fix: Fix[B[V, *]])(algebra: Algebra[B[V, *], A])(implicit B: BiFunctor[B]): A =
          algebra(B.second(fix.unfix)(cata(_)(algebra)))
    
        def cataTrace[B[_, _], V, I, D](fix: Fix[B[V, *]])(algebra: TraceAlgebra[B[V, *], I, D])(implicit B: BiFunctor[B]): (I => D) = { 
          algebra(B.second(fix.unfix)(cataTrace(algebra)(B)(_)))
        }

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Let's make our cata specific to attribute grammers </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
   
          def cataTrace[B[_, _], V, I, D](
            algebra: TraceAlgebra[B[V, *], I, D]
           )(implicit B: BiFunctor[B]): Fix[B[V, *]] => (I => D) = { 
             fix => algebra(B.second(fix.unfix)(cataTrace(algebra)(B)(_)))
          }

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Let's define attribute grammer for OpsF and Ops once and for all </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">

          // See Ops[A] here is Fix[OpsF[A, *]]

          def trace[A, B](f: B => B)(zero: B): Ops[A] => Ops[(A, B)] = {
            val algebra: OpsF[A, B => Ops[(A, B)]] => B => Ops[(A, B)] = {
              {
                // fb1 and fb2 is B => Ops[(A, B)]
                case SumF(fb1, fb2) => b => Fix(SumF(fb1(f(b)), fb2(f(b))))
                case LeafF(n)       => b => Fix(LeafF((n, b)))
              }
            }
        
            ops => {
              val fn: Fix[OpsF[A, *]] => B => Ops[(A, B)] = cataTrace(byDepthF)
              fn(ops)(f(zero))
            }
          }
        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>An example </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">
          val plan0 = 
           Fix(SumF(Fix(LeafF("query1")), Fix(LeafF("query2"))))
         
          val plan =
            Fix(SumF(plan0, Fix(LeafF("query3"))))

          println(plan)
          // Fix(NodeF(Fix(NodeF(Fix(LeafF((afsal,3))),Fix(LeafF((thaj,3))))),Fix(LeafF((thaj2,2)))))  
          
          def byDepth[A](plan: Ops[A]): Ops[(A, Int)] =
            trace(_ + 1)(0)(plan)

          byDepth(plan)  

         // Fix(NodeF(Fix(NodeF(Fix(LeafF((query1, 3))),Fix(LeafF((query2, 3))))),Fix(LeafF((query3, 2)))))

        </code></pre>
      </section>

      <section data-transition="fade-in">
        <h3>Well, why cata if we have para ! </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">

          // Para has the history of previous computation inputs, so a small change

          def trace[A, B](f: B => B)(zero: B): Ops[A] => Ops[(A, B)] = {
            val algebra: OpsF[A, B => Ops[(A, B)]] => B => Ops[(A, B)] = {
              {
                // fb1 and fb2 is B => Ops[(A, B)]
                case SumF(fb1, fb2) => b => Fix(SumF(fb1(f(b)), fb2(f(b))))
                case LeafF(n)       => b => Fix(LeafF((n, b)))
              }
            }
        
            ops => {
              val fn: Fix[OpsF[A, *]] => B => Ops[(A, B)] = cataTrace(byDepthF)
              fn(ops)(f(zero))
            }
          }
        </code></pre>
      </section>


      <section data-transition="fade-in">
        <h3>Well, why cata if we have para ! </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-40">

          // Para has the history of previous computation inputs, so a small change
          
          def trace[A, B](f: (Fix[OpsF[A, *]], B) => B)(zero: B): Ops[A] => Ops[(A, B)] = {
            val algebra: OpsF[A, (Fix[OpsF[A, *]], B => Ops[(A, B)])] => B => Ops[(A, B)] = {
              {
                case SumF((his1, fb1), (his2, fb2)) => b => Fix(SumF(fb1(f(his1, b)), fb2(f(his2, b))))
                case LeafF(n)                       => b => Fix(LeafF((n, b)))
              }
            }
        
            ops => {
              val fn: Fix[OpsF[A, *]] => B => Ops[(A, B)] = paraTrace(byDepthF)
              fn(tree)(f(ops, zero))
            }
          }

        </code></pre>
      </section>

    </div>
  </div>

  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      // ...

      // The "normal" size of the presentation, aspect ratio will be preserved
      // when the presentation is scaled to fit different resolutions. Can be
      // specified using percentage units.
      width: 1300,
      height: 750,

      // Factor of the display size that should remain empty around the content
      margin: 0.1,

      // Bounds for smallest/largest possible scale to apply to content
      minScale: 0.2,
      maxScale: 1.5,
      history: true,
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true },
        { src: 'https://d3js.org/d3.v4.min.js' },
        { src: 'plugin/d3js/d3js.js' }
      ]
    });
  </script>
</body>

</html>